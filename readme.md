# Fint - библиотека, реализующая ООП и строгую типизацию в OneScript

## Оглавление

- [Fint - библиотека, реализующая ООП и строгую типизацию в OneScript](#fint---библиотека-реализующая-ооп-и-строгую-типизацию-в-onescript)
  - [Оглавление](#оглавление)
  - [Возможности {#возможности}](#возможности-возможности)
  - [Планы по развитию {#планы-по-развитию}](#планы-по-развитию-планы-по-развитию)
    - [Установка {#установка}](#установка-установка)
    - [Синтаксис {#синтаксис}](#синтаксис-синтаксис)
    - [Использование {#использование}](#использование-использование)
      - [Разделение контекста (импорты) {#разделение-контекста-импорты}](#разделение-контекста-импорты-разделение-контекста-импорты)
      - [Создание экземпляров объектов {#создание-экземпляров-объектов}](#создание-экземпляров-объектов-создание-экземпляров-объектов)
      - [Создание свойств, методов и их типизация {#создание-свойств-методов-и-их-типизация}](#создание-свойств-методов-и-их-типизация-создание-свойств-методов-и-их-типизация)
      - [Работа с свойствами (инкапсуляция, геттеры и сеттеры) {#работа-с-свойствами-инкапсуляция-геттеры-и-сеттеры}](#работа-с-свойствами-инкапсуляция-геттеры-и-сеттеры-работа-с-свойствами-инкапсуляция-геттеры-и-сеттеры)
      - [Работа с процедурами и функциями {#работа-с-процедурами-и-функциями}](#работа-с-процедурами-и-функциями-работа-с-процедурами-и-функциями)
    - [Наследование {#наследование}](#наследование-наследование)
      - [Базовый класс: Фигура {#базовый-класс-фигура}](#базовый-класс-фигура-базовый-класс-фигура)
      - [Наследник: Круг {#наследник-круг}](#наследник-круг-наследник-круг)
      - [Наследник: Прямоугольник {#наследник-прямоугольник}](#наследник-прямоугольник-наследник-прямоугольник)
      - [Полиморфизм в массиве фигур {#полиморфизм-в-массиве-фигур}](#полиморфизм-в-массиве-фигур-полиморфизм-в-массиве-фигур)

## Возможности {#возможности}

- Разделение контекста: теперь не обязательно следить за уникальностью имён классов.
- Строгая типизация свойств классов, параметров методов и возвращаемых значений.
- Реализованы принципы ООП:
  - Наследование — один класс может расширить другой.
  - Инкапсуляция — модификаторы доступа, контролирующие доступ к свойствам (генерация геттеров и сеттеров).
  - Полиморфизм — дочерний класс может переопределять поведение родительского.
- Разработка библиотек для приложений, основанных на Fint, с использованием Fint.

[↑ В начало](#оглавление)

## Планы по развитию {#планы-по-развитию}

- Интерфейсы (совсем скоро).
- Несколько типов (сейчас доступен только `Любой`).
- Алиасы имён импортируемых классов.
- Встроенный DI-фреймворк (классическая реализация).
- Декораторы.
- Делегаты и анонимные функции.
- Асинхронность.
- Обходимые классы.
- Объекты «листы» для каждого класса.

### Установка {#установка}

Перед установкой у вас уже должна быть установлена платформа OneScript версией не менее 2.0RC8. Рекомендуется использовать [OVM](https://github.com/oscript-library/ovm) для установки платформы OneScript.

**Вариант 1**

Выполнить консольную команду: `opm install -l fint` (временно недоступно).

**Вариант 2**

1. Скачать ospx-файл с релизов (fint-x.x.x.ospx).
2. В каталоге вашего проекта разместить скачанный файл библиотеки (fint-x.x.x.ospx).
3. Выполнить консольную команду: `opm i -l -f fint-x.x.x.ospx`, где «x.x.x» — версия фреймворка (библиотеки).

[↑ В начало](#оглавление)

### Синтаксис {#синтаксис}

При использовании библиотеки понятие «модуль» исчезает; отныне есть только классы.

Пример обычного класса:

```bsl
&Импорт("пространство имен")
Перем КлассИзДругогоПакета;

&Число Перем ЧисловаяПеременная;

Перем Этот;

&КлассИзДругогоПакета Перем ОбъектДругогоКласса;

Процедура Конструктор(&Строка Текст, &Число КакоетоЧисло) Экспорт // Не обязателен

  Сообщить(Текст);

  Этот.ЧисловаяПеременная(КакоетоЧисло);
  Сообщить(Этот.ЧисловаяПеременная());

  Экземпляр = КлассИзДругогоПакета.Создать(Этот.ЧисловаяПеременная());
  Экземпляр.ВыполнитьЧтоТо();

КонецПроцедуры

&Число Функция МояФункция() Экспорт
  Возврат 5;
КонецФункции
```

Пример наследования:

```bsl
&Импорт("пространство имен родителя")
Перем КлассРодителя;

&Наследует("КлассРодителя")
Перем Этот, Базовый;

Процедура Конструктор() Экспорт // Не обязателен

КонецПроцедуры
```

[↑ В начало](#оглавление)

### Использование {#использование}

Для того чтобы начать пользоваться всеми возможностями библиотеки, необходимо выполнить некоторую подготовку.

1. Создать в корне проекта файл `main.os` со следующим содержимым:

   ```bsl
   #Использовать fint

   Приложение = Новый Приложение();
   Приложение.Запустить();
   ```

   Он служит только для подключения библиотек и запуска приложения.

2. Создать в корне проекта любой скрипт, который будет служить точкой входа. Для того чтобы класс определялся точкой входа, необходимо прописать аннотацию `ТочкаВхода` у свойства `Этот`. Также у класса точки входа обязательно должен быть конструктор с 1 параметром типа `ФиксированныйМассив`; в этот параметр будут передаваться аргументы командной строки. Пример:

   ```bsl
   &ТочкаВхода
   Перем Этот;

   Процедура Конструктор(&ФиксированныйМассив Аргументы) Экспорт

     Сообщить("Привет мир");

   КонецПроцедуры
   ```

3. Запустить выполнение скрипта командой `oscript main.os`.

На этом всё; дальше уже можно реализовывать любую логику. Если вы где-то ошибётесь, библиотека об этом сообщит.

Теперь давайте по порядку разберём, что и как.

#### Разделение контекста (импорты) {#разделение-контекста-импорты}

В данный момент присутствует проблема общего контекста всего приложения вместе с объектами его зависимостей. Это влечёт за собой ряд проблем: приходится следить за уникальностью наименований классов. Теперь подобных проблем не будет благодаря новому механизму. Теперь каждая папка в приложении — это отдельное пространство имён, которое просто импортируется в нужный нам объект и используется. Но импортируется оно не просто, а с указанием конкретных типов для использования внутри объекта.

Например, мы создали в корне папку `Природа` и в ней файл класса `Животное.os` со следующим содержимым:

```bsl
Перем Этот;

Процедура ПодатьГолос(&Строка Голос) Экспорт
  Сообщить(Голос);
КонецПроцедуры
```

Теперь, если мы хотим использовать этот класс в каком-либо другом объекте, нам достаточно просто его импортировать следующим образом:

```bsl
&Импорт("Природа")
Перем Животное;
```

Все импорты должны идти в самом начале текста модуля; имена свойств должны совпадать с импортируемым типом. Также можно импортировать несколько типов из одного пространства имён. Например, если в папке `Природа` помимо класса `Животное.os` есть ещё и класс `Насекомое.os`, то в случае необходимости его импорта мы можем его прописать:

```bsl
&Импорт("Приложение.Природа")
Перем Животное, Насекомое;
```

Желательно сохранять именно такой синтаксис; в противном случае импорты будут очень громоздкими. Далее импортированные типы можно использовать в аннотациях типов и создавать экземпляры объектов.

Если не указывать параметр у аннотации `&Импорт`, то поиск будет осуществляться внутри пространства имён, в котором находится сам объект. Если же указано, то требуется указание пути относительно корня приложения через точку в случае импортирования пространства имён из приложения, а если из подключённой библиотеки — тогда относительно корня библиотеки, то есть:

- Для импорта из приложения: `Приложение.Пространство.ВложенноеПространство`.
- Для импорта из библиотеки: `ИмяБиблиотеки.Пространство.ВложенноеПространство`.

#### Создание экземпляров объектов {#создание-экземпляров-объектов}

После того как мы импортируем нужные типы, мы можем создавать их экземпляры. Делается это, к сожалению, не привычным нам образом: у каждого свойства импортированного типа есть процедура `Создать(Парам1, Парам2 ... Парам7)`. Параметры этой процедуры не обязательны и дублируют параметры конструктора создаваемого объекта:

```bsl
&Импорт("Приложение.Природа")
Перем Животное;

Перем Этот;

Процедура Конструктор(&ФиксированныйМассив Аргументы) Экспорт

  МоеЖивотное = Животное.Создать();

  // Далее можно работать как с обычным объектом
  МоеЖивотное.ПодатьГолос("Хрю");

КонецПроцедуры
```

#### Создание свойств, методов и их типизация {#создание-свойств-методов-и-их-типизация}

Теперь пришло время обсудить типизацию. Устроена она довольно просто: достаточно прописать аннотацию с именем типа перед ключевыми словами `Перем`, `Функция` и перед именами параметров. Начнём с создания свойств:

```bsl
Перем Этот;

&Число Перем ЧисловаяПеременная;
&Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

Процедура Конструктор() Экспорт

КонецПроцедуры
```

Синтаксис объявления следующий: `<АннотацияТипа> Перем <ИмяСвойства>;`. Если не прописать аннотацию типа, то мы получим ошибку ещё до запуска приложения. Также не запрещено добавлять какие-либо свои аннотации над свойствами. Запрещено создавать экспортные свойства.

Теперь рассмотрим создание функции:

```bsl
Перем Этот;

&Число Функция МояФункция(&Число КакоеТоЧисло) Экспорт
  Возврат КакоеТоЧисло;
КонецФункции
```

Здесь мы сразу рассмотрели и указание типа для параметра. Обратите внимание на то, как указывается аннотация типа функции. Без указания аннотаций типа приложение не запустится, а библиотека оповестит об этом.

В качестве аннотаций типов может быть использовано любое имя типа, не только примитивы, а абсолютно любой тип, доступный в контексте. Отличается лишь прописание импортированных типов; эти аннотации типов прописываются так же, как и созданное свойство, например:

```bsl
&Импорт("Приложение.Природа")
Перем Животное;

Перем Этот;

&Животное Функция МоеЖивотное() Экспорт
  Возврат Животное.Создать();
КонецФункции
```

Точно так же оно прописывается для свойств и параметров.

#### Работа с свойствами (инкапсуляция, геттеры и сеттеры) {#работа-с-свойствами-инкапсуляция-геттеры-и-сеттеры}

Помимо обычного создания свойства с указанием типа, можно также указать и модификатор доступа в виде аннотации. Их существует всего 2:

- `&Чтение`
- `&ЧтениеИЗапись`

Не трудно догадаться по названиям, что делают эти аннотации. А выглядит это так:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

Процедура Конструктор() Экспорт

КонецПроцедуры
```

Если аннотация модификатора доступа не указана, то свойство будет считаться приватным.

А теперь самое главное: использовать присваивание свойствам объекта напрямую крайне нежелательно — просто не будет работать типизация, и возможно, что-то сломается. Вместо этого автоматически генерируются одноимённые свойствам функции, которые служат для установки и получения значения свойства одновременно. Модификаторы доступа работают только для вызовов извне; локально же все свойства по умолчанию доступны для чтения и записи. Вот пример:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

Процедура Конструктор() Экспорт

  // Неправильное присвоение
  ЧисловаяПеременная = 5;

  // Правильное присвоение
  Этот.ЧисловаяПеременная(5);

КонецПроцедуры
```

То есть для работы со свойствами объекта обязательно нужно обращаться через свойство `Этот`.

А теперь рассмотрим работу со свойствами извне. Предположим, что предыдущий пример — это тип «ТестовыйТип», и рассмотрим пример:

```bsl
&Импорт
Перем ТестовыйТип;

Перем Этот;

Процедура Конструктор() Экспорт

  ОбъектТестовогоТипа = ТестовыйТип.Создать();

  // Если обратиться напрямую, то мы получим ошибку отсутствия свойства
  Переменная = ОбъектТестовогоТипа.ЧисловаяПеременная;

  // Для получения значения свойства нужно вызывать одноимённую функцию
  Переменная = ОбъектТестовогоТипа.ЧисловаяПеременная();

  // Но если мы вызовем функцию приватного свойства, то получим ошибку
  Переменная = ОбъектТестовогоТипа.ЛогичПеременная();

  // Чтобы установить свойство, нужно вызывать функцию и передать в неё значение.
  // Доступно это только для свойств с &ЧтениеИЗапись; в остальных случаях выдаст ошибку.
  ОбъектТестовогоТипа.СтроковаяПеременная("Привет");

КонецПроцедуры
```

Есть очень интересный функционал: если нужно переопределить поведение функции геттера-сеттера, то достаточно просто создать одноимённую экспортную функцию с присвоением аннотации типа такой, какая указана у свойства:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

&Число Функция ЧисловаяПеременная(&Число Значение) Экспорт

  Если Значение <> NULL Тогда
    ЧисловаяПеременная = Значение;
  КонецЕсли;

  Возврат ЧисловаяПеременная;

КонецФункции
```

Здесь вы сможете реализовать любую логику для установки и получения. Отмечу, что после переопределения функции вопрос с доступностью решается программистом; аннотация модификатора доступа игнорируется.

#### Работа с процедурами и функциями {#работа-с-процедурами-и-функциями}

В целом тут ничего не поменялось, единственное, что вызов локальных процедур и функций должен производиться строго через свойство `Этот`:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

Процедура Конструктор() Экспорт

  Результат = Этот.МояФункция(4);
  Этот.МояПроцедура(Результат);

КонецПроцедуры

Процедура МояПроцедура(&Число Значение)
  Сообщить(Значение);
КонецПроцедуры

Функция МояФункция(&Число Значение)
  Возврат Значение + 1;
КонецФункции
```

Соответственно, если у процедуры есть `Экспорт`, то поведение извне будет управляться этим модификатором.

[↑ В начало](#оглавление)

### Наследование {#наследование}

Наследование в Fint реализуется через аннотацию `&Наследует("ИмяТипаБазовогоКласса")` и переменную `Перем Этот, Базовый;`. Переменная `Базовый` предоставляет доступ к методам и свойствам родительского класса, позволяя вызывать их из дочернего (например, `Базовый.Метод()`). Это обеспечивает возможность переопределения методов с вызовом базовой реализации, если нужно.

Рассмотрим пример с геометрическими фигурами. Базовый класс `Фигура` определяет общие свойства (с типизацией и инкапсуляцией) и абстрактный метод `Площадь()` (аннотированный как `&Число`, но без реализации — для переопределения в наследниках).

#### Базовый класс: Фигура {#базовый-класс-фигура}

```bsl
Перем Этот;

// Свойства с типизацией и инкапсуляцией (только чтение)
&Чтение &Число Перем Идентификатор;
&Чтение &Строка Перем Название;

// Абстрактный метод для переопределения (строгая типизация возвращаемого значения)
&Число Функция Площадь() Экспорт
    // Абстрактный метод - должен быть переопределён в наследниках
    ВызватьИсключение "Метод Площадь() должен быть переопределён";
КонецФункции

Процедура Конструктор(&Строка Название) Экспорт
    Этот.Название(Название);
    Этот.Идентификатор(Строка(Новый УникальныйИдентификатор()));
КонецПроцедуры
```

Здесь свойства `Идентификатор` и `Название` типизированы (`&Число`, `&Строка`) и защищены инкапсуляцией (`&Чтение`), доступны только для чтения через `Этот.Свойство()`. Метод `Площадь()` объявлен с типом `&Число`, но выбрасывает исключение, чтобы требовать переопределения.

#### Наследник: Круг {#наследник-круг}

```bsl
&Импорт
Перем Фигура;

&Наследует("Фигура")
Перем Этот, Базовый;

// Дополнительное свойство для круга (инкапсуляция)
&Чтение &Число Перем Радиус;

&Число Функция Площадь() Экспорт
    // Переопределение базового метода (полиморфизм)
    // Вызов базового метода не обязателен, поскольку он абстрактный
    ПлощадьКруга = 3.14159 * Этот.Радиус() * Этот.Радиус();
    Возврат ПлощадьКруга;
КонецФункции

Процедура Конструктор(&Число Радиус) Экспорт
    // Вызов конструктора базового класса
    Базовый.Конструктор("Круг");
    Этот.Радиус(Радиус);
КонецПроцедуры
```

В `Круг` импортируется `Фигура`, наследуется через `&Наследует`. Свойство `Радиус` типизировано и защищено. Метод `Площадь()` переопределяет базовый, вычисляя площадь по формуле π\*r², возвращая `&Число`. Конструктор вызывает `Базовый.Конструктор()` для инициализации родительских свойств.

#### Наследник: Прямоугольник {#наследник-прямоугольник}

```bsl
&Импорт
Перем Фигура;

&Наследует("Фигура")
Перем Этот, Базовый;

// Свойства для прямоугольника
&Чтение &Число Перем Ширина;
&Чтение &Число Перем Высота;

&Число Функция Площадь() Экспорт
    // Переопределение базового метода
    ПлощадьПрямоугольника = Этот.Ширина() * Этот.Высота();
    // Пример вызова базового метода (если бы он имел реализацию, например, для добавления базовой логики)
    // Базовый.Площадь(); // Здесь можно добавить, если базовый не абстрактный
    Возврат ПлощадьПрямоугольника;
КонецФункции

Процедура Конструктор(&Число Ширина, &Число Высота) Экспорт
    Базовый.Конструктор("Прямоугольник");
    Этот.Ширина(Ширина);
    Этот.Высота(Высота);
КонецПроцедуры
```

Аналогично `Круг`, но с двумя свойствами `Ширина` и `Высота`. `Площадь()` вычисляет ширину \* высоту. Показан комментарий о возможном вызове `Базовый.Площадь()` для демонстрации доступа к родительским методам.

#### Полиморфизм в массиве фигур {#полиморфизм-в-массиве-фигур}

В точке входа (например, main.os или другом скрипте) создайте экземпляры и используйте полиморфно:

```bsl
&Импорт
Перем Фигура, Круг, Прямоугольник;

&ТочкаВхода
Перем Этот;

Процедура Конструктор(&ФиксированныйМассив Аргументы) Экспорт
    // Создание экземпляров
    Круг1 = Круг.Создать(5);
    Прямоугольник1 = Прямоугольник.Создать(4, 6);

    // Массив фигур (полиморфизм: разные типы, общий интерфейс)
    Фигуры = Новый Массив;
    Фигуры.Добавить(Круг1);
    Фигуры.Добавить(Прямоугольник1);

    // Полиморфный вызов: каждый объект использует свою реализацию Площадь()
    ОбщаяПлощадь = 0;
    Для Каждого Фигура Из Фигуры Цикл
        ОбщаяПлощадь = ОбщаяПлощадь + Фигура.Площадь();
        Сообщить("Площадь " + Фигура.Название() + ": " + Фигура.Площадь());
    КонецЦикла;

    Сообщить("Общая площадь: " + ОбщаяПлощадь);
КонецПроцедуры
```

Здесь полиморфизм проявляется в том, что метод `Площадь()` вызывается на объектах разных типов (`Круг`, `Прямоугольник`), но каждый возвращает свой результат. Доступ к общим свойствам (`Название`) через наследуемые от `Фигура`. Все вызовы через `Этот` или объект обеспечивают инкапсуляцию и типизацию.

Этот пример демонстрирует ключевые аспекты: наследование для расширения, `Базовый` для доступа к родителям, строгую типизацию (`&Число`), инкапсуляцию (`&Чтение`) и полиморфизм в коллекциях.

Как вы можете наблюдать, аннотации типов всегда прописываются перед ключевыми словами: `Перем`, `Функция`, и перед названиями параметров. Это не обязательно, просто код так выглядит чище. Самое главное — чтобы аннотация типа была самой последней.

[↑ В начало](#оглавление)
