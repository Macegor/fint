## Работа с свойствами (инкапсуляция, геттеры и сеттеры)

Помимо обычного создания свойства с указанием типа, можно также указать и модификатор доступа в виде аннотации. Их существует всего 2:

- `&Чтение`

- `&ЧтениеИЗапись`

Не трудно догадаться по названиям, что делают эти аннотации. А выглядит это так:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

Процедура Конструктор() Экспорт

КонецПроцедуры
```

Если аннотация модификатора доступа не указана, то свойство будет считаться приватным.

А теперь самое главное: использовать присваивание свойствам объекта напрямую крайне нежелательно — просто не будет работать типизация, и возможно, что-то сломается. Вместо этого автоматически генерируются одноимённые свойствам функции, которые служат для установки и получения значения свойства одновременно. Модификаторы доступа работают только для вызовов извне; локально же все свойства по умолчанию доступны для чтения и записи. Вот пример:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

Процедура Конструктор() Экспорт

  // Неправильное присвоение
  ЧисловаяПеременная = 5;

  // Правильное присвоение
  Этот.ЧисловаяПеременная(5);

КонецПроцедуры
```

То есть для работы со свойствами объекта обязательно нужно обращаться через свойство `Этот`.

А теперь рассмотрим работу со свойствами извне. Предположим, что предыдущий пример — это тип «ТестовыйТип», и рассмотрим пример:

```bsl
&Импорт
Перем ТестовыйТип;

Перем Этот;

Процедура Конструктор() Экспорт

  ОбъектТестовогоТипа = ТестовыйТип.Создать();

  // Если обратиться напрямую, то мы получим ошибку отсутствия свойства
  Переменная = ОбъектТестовогоТипа.ЧисловаяПеременная;

  // Для получения значения свойства нужно вызывать одноимённую функцию
  Переменная = ОбъектТестовогоТипа.ЧисловаяПеременная();

  // Но если мы вызовем функцию приватного свойства, то получим ошибку
  Переменная = ОбъектТестовогоТипа.ЛогичПеременная();

  // Чтобы установить свойство, нужно вызывать функцию и передать в неё значение.
  // Доступно это только для свойств с &ЧтениеИЗапись; в остальных случаях выдаст ошибку.
  ОбъектТестовогоТипа.СтроковаяПеременная("Привет");

КонецПроцедуры
```

Есть очень интересный функционал: если нужно переопределить поведение функции геттера-сеттера, то достаточно просто создать одноимённую экспортную функцию с присвоением аннотации типа такой, какая указана у свойства:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

&Число Функция ЧисловаяПеременная(&Число Значение) Экспорт

  Если Значение <> NULL Тогда
    ЧисловаяПеременная = Значение;
  КонецЕсли;

  Возврат ЧисловаяПеременная;

КонецФункции
```

Здесь вы сможете реализовать любую логику для установки и получения. Отмечу, что после переопределения функции вопрос с доступностью решается программистом; аннотация модификатора доступа игнорируется.