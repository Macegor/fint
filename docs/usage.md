
# Использование

Для того чтобы начать пользоваться всеми возможностями библиотеки, необходимо выполнить некоторую подготовку.

1. Создать в корне проекта файл `main.os` со следующим содержимым:

   ```bsl
   #Использовать fint

   Приложение = Новый Приложение();
   Приложение.Запустить();
   ```

   Он служит только для подключения библиотек и запуска приложения.

2. Создать в корне проекта любой скрипт, который будет служить точкой входа. Для того чтобы класс определялся точкой входа, необходимо прописать аннотацию `ТочкаВхода` у свойства `Этот`. Также у класса точки входа обязательно должен быть конструктор с 1 параметром типа `ФиксированныйМассив`; в этот параметр будут передаваться аргументы командной строки. Пример:

   ```bsl
   &ТочкаВхода
   Перем Этот;

   Процедура Конструктор(&ФиксированныйМассив Аргументы) Экспорт

     Сообщить("Привет мир");

   КонецПроцедуры
   ```

3. Запустить выполнение скрипта командой `oscript main.os`.

На этом всё; дальше уже можно реализовывать любую логику. Если вы где-то ошибётесь, библиотека об этом сообщит.

Теперь давайте по порядку разберём, что и как.

## Разделение контекста (импорты)

В данный момент присутствует проблема общего контекста всего приложения вместе с объектами его зависимостей. Это влечёт за собой ряд проблем: приходится следить за уникальностью наименований классов. Теперь подобных проблем не будет благодаря новому механизму. Теперь каждая папка в приложении — это отдельное пространство имён, которое просто импортируется в нужный нам объект и используется. Но импортируется оно не просто, а с указанием конкретных типов для использования внутри объекта.

Например, мы создали в корне папку `Природа` и в ней файл класса `Животное.os` со следующим содержимым:

```bsl
Перем Этот;

Процедура ПодатьГолос(&Строка Голос) Экспорт
  Сообщить(Голос);
КонецПроцедуры
```

Теперь, если мы хотим использовать этот класс в каком-либо другом объекте, нам достаточно просто его импортировать следующим образом:

```bsl
&Импорт("Природа")
Перем Животное;
```

Все импорты должны идти в самом начале текста модуля; имена свойств должны совпадать с импортируемым типом. Также можно импортировать несколько типов из одного пространства имён. Например, если в папке `Природа` помимо класса `Животное.os` есть ещё и класс `Насекомое.os`, то в случае необходимости его импорта мы можем его прописать:

```bsl
&Импорт("Приложение.Природа")
Перем Животное, Насекомое;
```

Желательно сохранять именно такой синтаксис; в противном случае импорты будут очень громоздкими. Далее импортированные типы можно использовать в аннотациях типов и создавать экземпляры объектов.

Если не указывать параметр у аннотации `&Импорт`, то поиск будет осуществляться внутри пространства имён, в котором находится сам объект. Если же указано, то требуется указание пути относительно корня приложения через точку в случае импортирования пространства имён из приложения, а если из подключённой библиотеки — тогда относительно корня библиотеки, то есть:

- Для импорта из приложения: `Приложение.Пространство.ВложенноеПространство`.

- Для импорта из библиотеки: `ИмяБиблиотеки.Пространство.ВложенноеПространство`.

## Создание экземпляров объектов

После того как мы импортируем нужные типы, мы можем создавать их экземпляры. Делается это, к сожалению, не привычным нам образом: у каждого свойства импортированного типа есть процедура `Создать(Парам1, Парам2 ... Парам7)`. Параметры этой процедуры не обязательны и дублируют параметры конструктора создаваемого объекта:

```bsl
&Импорт("Приложение.Природа")
Перем Животное;

Перем Этот;

Процедура Конструктор(&ФиксированныйМассив Аргументы) Экспорт

  МоеЖивотное = Животное.Создать();

  // Далее можно работать как с обычным объектом
  МоеЖивотное.ПодатьГолос("Хрю");

КонецПроцедуры
```

## Создание свойств, методов и их типизация

Теперь пришло время обсудить типизацию. Устроена она довольно просто: достаточно прописать аннотацию с именем типа перед ключевыми словами `Перем`, `Функция` и перед именами параметров. Начнём с создания свойств:

```bsl
Перем Этот;

&Число Перем ЧисловаяПеременная;
&Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

Процедура Конструктор() Экспорт

КонецПроцедуры
```

Синтаксис объявления следующий: `<АннотацияТипа> Перем <ИмяСвойства>;`. Если не прописать аннотацию типа, то мы получим ошибку ещё до запуска приложения. Также не запрещено добавлять какие-либо свои аннотации над свойствами. Запрещено создавать экспортные свойства.

Теперь рассмотрим создание функции:

```bsl
Перем Этот;

&Число Функция МояФункция(&Число КакоеТоЧисло) Экспорт
  Возврат КакоеТоЧисло;
КонецФункции
```

Здесь мы сразу рассмотрели и указание типа для параметра. Обратите внимание на то, как указывается аннотация типа функции. Без указания аннотаций типа приложение не запустится, а библиотека оповестит об этом.

В качестве аннотаций типов может быть использовано любое имя типа, не только примитивы, а абсолютно любой тип, доступный в контексте. Отличается лишь прописание импортированных типов; эти аннотации типов прописываются так же, как и созданное свойство, например:

```bsl
&Импорт("Приложение.Природа")
Перем Животное;

Перем Этот;

&Животное Функция МоеЖивотное() Экспорт
  Возврат Животное.Создать();
КонецФункции
```

Точно так же оно прописывается для свойств и параметров.

## Работа с свойствами (инкапсуляция, геттеры и сеттеры)

Помимо обычного создания свойства с указанием типа, можно также указать и модификатор доступа в виде аннотации. Их существует всего 2:

- `&Чтение`

- `&ЧтениеИЗапись`

Не трудно догадаться по названиям, что делают эти аннотации. А выглядит это так:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

Процедура Конструктор() Экспорт

КонецПроцедуры
```

Если аннотация модификатора доступа не указана, то свойство будет считаться приватным.

А теперь самое главное: использовать присваивание свойствам объекта напрямую крайне нежелательно — просто не будет работать типизация, и возможно, что-то сломается. Вместо этого автоматически генерируются одноимённые свойствам функции, которые служат для установки и получения значения свойства одновременно. Модификаторы доступа работают только для вызовов извне; локально же все свойства по умолчанию доступны для чтения и записи. Вот пример:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

Процедура Конструктор() Экспорт

  // Неправильное присвоение
  ЧисловаяПеременная = 5;

  // Правильное присвоение
  Этот.ЧисловаяПеременная(5);

КонецПроцедуры
```

То есть для работы со свойствами объекта обязательно нужно обращаться через свойство `Этот`.

А теперь рассмотрим работу со свойствами извне. Предположим, что предыдущий пример — это тип «ТестовыйТип», и рассмотрим пример:

```bsl
&Импорт
Перем ТестовыйТип;

Перем Этот;

Процедура Конструктор() Экспорт

  ОбъектТестовогоТипа = ТестовыйТип.Создать();

  // Если обратиться напрямую, то мы получим ошибку отсутствия свойства
  Переменная = ОбъектТестовогоТипа.ЧисловаяПеременная;

  // Для получения значения свойства нужно вызывать одноимённую функцию
  Переменная = ОбъектТестовогоТипа.ЧисловаяПеременная();

  // Но если мы вызовем функцию приватного свойства, то получим ошибку
  Переменная = ОбъектТестовогоТипа.ЛогичПеременная();

  // Чтобы установить свойство, нужно вызывать функцию и передать в неё значение.
  // Доступно это только для свойств с &ЧтениеИЗапись; в остальных случаях выдаст ошибку.
  ОбъектТестовогоТипа.СтроковаяПеременная("Привет");

КонецПроцедуры
```

Есть очень интересный функционал: если нужно переопределить поведение функции геттера-сеттера, то достаточно просто создать одноимённую экспортную функцию с присвоением аннотации типа такой, какая указана у свойства:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

&Число Функция ЧисловаяПеременная(&Число Значение) Экспорт

  Если Значение <> NULL Тогда
    ЧисловаяПеременная = Значение;
  КонецЕсли;

  Возврат ЧисловаяПеременная;

КонецФункции
```

Здесь вы сможете реализовать любую логику для установки и получения. Отмечу, что после переопределения функции вопрос с доступностью решается программистом; аннотация модификатора доступа игнорируется.

## Работа с процедурами и функциями

В целом тут ничего не поменялось, единственное, что вызов локальных процедур и функций должен производиться строго через свойство `Этот`:

```bsl
Перем Этот;

&Чтение &Число Перем ЧисловаяПеременная;
&ЧтениеИЗапись &Строка Перем СтроковаяПеременная;
&Булево Перем ЛогичПеременная;

Процедура Конструктор() Экспорт

  Результат = Этот.МояФункция(4);
  Этот.МояПроцедура(Результат);

КонецПроцедуры

Процедура МояПроцедура(&Число Значение)
  Сообщить(Значение);
КонецПроцедуры

Функция МояФункция(&Число Значение)
  Возврат Значение + 1;
КонецФункции
```

Соответственно, если у процедуры есть `Экспорт`, то поведение извне будет управляться этим модификатором.
<line_count>259</line_count>
</write_to_file>