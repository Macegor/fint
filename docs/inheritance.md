# Наследование

Наследование в Fint реализуется через аннотацию `&Наследует("ИмяТипаБазовогоКласса")` и переменную `Перем Этот, Базовый;`. Переменная `Базовый` предоставляет доступ к методам и свойствам родительского класса, позволяя вызывать их из дочернего (например, `Базовый.Метод()`). Это обеспечивает возможность переопределения методов с вызовом базовой реализации, если нужно.

Рассмотрим пример с геометрическими фигурами. Базовый класс `Фигура` определяет общие свойства (с типизацией и инкапсуляцией) и абстрактный метод `Площадь()` (аннотированный как `&Число`, но без реализации — для переопределения в наследниках).

## Базовый класс: Фигура

```bsl
Перем Этот;

// Свойства с типизацией и инкапсуляцией (только чтение)
&Чтение &Число Перем Идентификатор;
&Чтение &Строка Перем Название;

// Абстрактный метод для переопределения (строгая типизация возвращаемого значения)
&Число Функция Площадь() Экспорт
    // Абстрактный метод - должен быть переопределён в наследниках
    ВызватьИсключение "Метод Площадь() должен быть переопределён";
КонецФункции

Процедура Конструктор(&Строка Название) Экспорт
    Этот.Название(Название);
    Этот.Идентификатор(Строка(Новый УникальныйИдентификатор()));
КонецПроцедуры
```

Здесь свойства `Идентификатор` и `Название` типизированы (`&Число`, `&Строка`) и защищены инкапсуляцией (`&Чтение`), доступны только для чтения через `Этот.Свойство()`. Метод `Площадь()` объявлен с типом `&Число`, но выбрасывает исключение, чтобы требовать переопределения.

## Наследник: Круг

```bsl
&Импорт
Перем Фигура;

&Наследует("Фигура")
Перем Этот, Базовый;

// Дополнительное свойство для круга (инкапсуляция)
&Чтение &Число Перем Радиус;

&Число Функция Площадь() Экспорт
    // Переопределение базового метода (полиморфизм)
    // Вызов базового метода не обязателен, поскольку он абстрактный
    ПлощадьКруга = 3.14159 * Этот.Радиус() * Этот.Радиус();
    Возврат ПлощадьКруга;
КонецФункции

Процедура Конструктор(&Число Радиус) Экспорт
    // Вызов конструктора базового класса
    Базовый.Конструктор("Круг");
    Этот.Радиус(Радиус);
КонецПроцедуры
```

В `Круг` импортируется `Фигура`, наследуется через `&Наследует`. Свойство `Радиус` типизировано и защищено. Метод `Площадь()` переопределяет базовый, вычисляя площадь по формуле π*r², возвращая `&Число`. Конструктор вызывает `Базовый.Конструктор()` для инициализации родительских свойств.

## Наследник: Прямоугольник

```bsl
&Импорт
Перем Фигура;

&Наследует("Фигура")
Перем Этот, Базовый;

// Свойства для прямоугольника
&Чтение &Число Перем Ширина;
&Чтение &Число Перем Высота;

&Число Функция Площадь() Экспорт
    // Переопределение базового метода
    ПлощадьПрямоугольника = Этот.Ширина() * Этот.Высота();
    // Пример вызова базового метода (если бы он имел реализацию, например, для добавления базовой логики)
    // Базовый.Площадь(); // Здесь можно добавить, если базовый не абстрактный
    Возврат ПлощадьПрямоугольника;
КонецФункции

Процедура Конструктор(&Число Ширина, &Число Высота) Экспорт
    Базовый.Конструктор("Прямоугольник");
    Этот.Ширина(Ширина);
    Этот.Высота(Высота);
КонецПроцедуры
```

Аналогично `Круг`, но с двумя свойствами `Ширина` и `Высота`. `Площадь()` вычисляет ширину * высоту. Показан комментарий о возможном вызове `Базовый.Площадь()` для демонстрации доступа к родительским методам.

## Полиморфизм в массиве фигур

В точке входа (например, main.os или другом скрипте) создайте экземпляры и используйте полиморфно:

```bsl
&Импорт
Перем Фигура, Круг, Прямоугольник;

&ТочкаВхода
Перем Этот;

Процедура Конструктор(&ФиксированныйМассив Аргументы) Экспорт
    // Создание экземпляров
    Круг1 = Круг.Создать(5);
    Прямоугольник1 = Прямоугольник.Создать(4, 6);

    // Массив фигур (полиморфизм: разные типы, общий интерфейс)
    Фигуры = Новый Массив;
    Фигуры.Добавить(Круг1);
    Фигуры.Добавить(Прямоугольник1);

    // Полиморфный вызов: каждый объект использует свою реализацию Площадь()
    ОбщаяПлощадь = 0;
    Для Каждого Фигура Из Фигуры Цикл
        ОбщаяПлощадь = ОбщаяПлощадь + Фигура.Площадь();
        Сообщить("Площадь " + Фигура.Название() + ": " + Фигура.Площадь());
    КонецЦикла;

    Сообщить("Общая площадь: " + ОбщаяПлощадь);
КонецПроцедуры
```

Здесь полиморфизм проявляется в том, что метод `Площадь()` вызывается на объектах разных типов (`Круг`, `Прямоугольник`), но каждый возвращает свой результат. Доступ к общим свойствам (`Название`) через наследуемые от `Фигура`. Все вызовы через `Этот` или объект обеспечивают инкапсуляцию и типизацию.

Этот пример демонстрирует ключевые аспекты: наследование для расширения, `Базовый` для доступа к родителям, строгую типизацию (`&Число`), инкапсуляцию (`&Чтение`) и полиморфизм в коллекциях.

Как вы можете наблюдать, аннотации типов всегда прописываются перед ключевыми словами: `Перем`, `Функция`, и перед названиями параметров. Это не обязательно, просто код так выглядит чище. Самое главное — чтобы аннотация типа была самой последней.